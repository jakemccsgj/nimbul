#!/usr/bin/env ruby

#
# Account: <%= user_script.account.name %> [<%= user_script.account.id %>]
# Cluster: <%= user_script.cluster.name %> [<%= user_script.cluster.id %>]
# Server: <%= user_script.server.name %> [<%= user_script.server.id %>]
#

#### Server Instance Details ####

#
# AMI: <%= user_script.server.image_id %> - <%= ServerImage.find_by_image_id(user_script.server.image_id).location %>
# Default Key: <%= user_script.server.key_name %>
# Instance Type: <%= user_script.server.instance_type %>
# Security Groups: <%= user_script.security_groups.join(", ") %>
#

####################
#### Resources #####
####################
#
# Volumes:
#<%= user_script.server.volumes.collect { |v| "\t#{v.cloud_resource.cloud_id} -> #{v.mount_point}" }.join "\n#\t" %>
#
# Addresses:
#<%= user_script.server.addresses.collect { |a| sprintf("\t%-16s\t%s", a.cloud_resource.cloud_id, a.cloud_resource.name) }.join "\n#\t" %>
#

require 'ostruct'
require 'optparse'
require 'readline'
require 'fcntl'
require 'json'

def update_program_name
  # allow setting of program name if using a tar/gzip loader
  arg, program_name = (ARGV[ARGV.index('--program-name'),2] rescue [ nil, nil ])
  unless program_name =~ /^-/
    new_argv = ARGV - [arg, program_name]
  else
    new_argv = ARGV - [arg]
    program_name = nil
  end
  ARGV.clear
  new_argv.each { |a| ARGV << a }
  program_name || $0
end

$0 = update_program_name

class << $stdin
  def has_data?
    self.fcntl(Fcntl::F_GETFL, 0) == 0
  end
end

class Object
  def try method, *args
    self.__send__(method.to_s.to_sym, *args) unless not respond_to? method.to_s.to_sym
  end
end

class Symbol
  def <=>(test); self.to_s <=> test.to_s; end
end

class Array
  def symbolize_keys
    inject([]) do |array, value|
      array << case value
        when Hash, Array
          value.symbolize_keys
        else
          value
      end
      array
    end
  end
    
  def symbolize_keys!
    self.replace(self.symbolize_keys)
  end
end

class Hash
  def symbolize_keys
    inject({}) do |options, (key, value)|
      options[(key.to_sym rescue key) || key] = case value
        when Hash, Array
          value = value.symbolize_keys
        else
          value
      end
      options
    end
  end
  
  def symbolize_keys!
    self.replace(self.symbolize_keys)
  end
end

COMMANDS = [ :run, :start, :stop, :reboot, :list, :hosts ]

BUILD_DATE      = '<%= Time.now -%>'
SERVER_NAME     = '<%= user_script.server.name -%>'
SERVER_ID       = '<%= user_script.server.id -%>'.to_i
IMAGE_AMI       = '<%= user_script.server.image_id -%>'
HOSTSFILE_URL   = '<%= user_script.hosts_file_url -%>'
SECURITY_GROUPS = %w(<%= user_script.security_groups.join(' ') -%>)
INSTANCE_TYPE   = '<%= user_script.server.instance_type -%>'
KEY_NAME        = '<%= user_script.server.key_name -%>'
VOLUMES         = Hash[*%w(<%= user_script.volumes.join ' ' -%>)]
ADDRESSES       = %w(<%= user_script.addresses.join ' ' -%>)
ZONE            = '<%= user_script.server.zones.first.name rescue '' -%>'
USER_DATA       = DATA.read

Signal.trap("INT") { exit 2 }

class Ec2
  attr_reader :ec2, :instance
  def initialize ec2, instance
    @ec2 = ec2
    @instance = instance
  end
  
  def attach volume_id, mount_point
    ec2.attach_volume volume_id, @instance, mount_point
  end
  
  def detach volume_id, instance_id = nil, device = nil, force = nil
    ec2.detach_volume volume_id, instance_id, device, force
  end
  
  def attached? volume_id
    ec2.describe_volumes(volume_id).any? { |v| v[:status] != 'available' } rescue false
  end

  def associate address
    ec2.associate_address @instance, address
  end
  
  def disassociate address
    ec2.disassociate_address address
  end
  
  def associated? address
    ec2.describe_addresses(address).any? { |v| !v[:instance_id].nil? } rescue false
  end
end

###############################################################################################################
################################################### Parser ####################################################
###############################################################################################################

class CommandParser
  attr_reader :options, :parser
  
  def self.instance
    @@parser ||= begin
      command = (ARGV[0] || 'missing').downcase.to_sym
      unless COMMANDS.include? command
        command = :missing
        CommandParser.new(command)
      else
        ARGV.shift
        CommandParser.const_get(command.to_s.capitalize).new(command)
      end
    end
  end

  def initialize command
    @parser = nil

    @options = OpenStruct.new
    options.verbose = false
    options.debug   = false
    options.help    = false
    options.exit    = false
    options.trace   = false
    options.command = command
    options.showinfo = false

    setup unless not respond_to? :setup
  end

  def help!
    options.help = options.exit = true
  end

  def banner
    unless options.command == :missing
      parser.banner = "Usage: #{File.basename($0, '.*')} #{options.command.to_s} "

      unless not respond_to? :lead_in
        lead_in
        parser.separator ""
      end
      
      subcmd = options.subcommand && options.subcommand != :missing ? options.subcommand.to_s.capitalize : "\b"
      parser.separator "#{options.command.to_s.capitalize} #{subcmd} Options:"
    else
      parser.separator "Valid Commands:"
      parser.separator ""
      parser.separator "  run     - Runs a shell command on all instances of this server"
      parser.separator "  hosts   - Put or Get the hosts file that this server uses"
      parser.separator "  list    - List all instances of this server"
      parser.separator "  reboot  - Reboot an instance of this server"
      parser.separator "  start   - Start an instance of this server"
      parser.separator "  stop    - Stop an instance of this server"
    end
  end

  def parse
    OptionParser.new do |parser|
      @parser = parser
      
      self.help! if options.command == :missing
      
      parser.banner = "Usage: #{File.basename($0)} <command> [options]"
      parser.separator ""

      banner
      build
      
      parser.separator ""
      parser.separator "Common options:"

      parser.on('-d', '--[no-]debug', 'Turn on debugging') { |d| options.debug = !!d }
      parser.on('-v', '--[no-]verbose', 'Increase verbosity level') { |v| options.verbose = !!v }
      parser.on('--trace', 'Turn on display of exception backtrace') { |v| options.trace = true }

      parser.on('--server-info', 'Display server details') do
        puts "Embedded Server Details:"
        puts
        puts sprintf("%-20s: \t%s\n", "BUILD_DATE", "#{::BUILD_DATE}")
        puts sprintf("%-20s: \t%s\n", "SERVER_ID", "#{::SERVER_ID}")
        puts sprintf("%-20s: \t%s\n", "SERVER_NAME", "#{::SERVER_NAME}")
        puts sprintf("%-20s: \t%s\n", "ZONE", "#{::ZONE}")
        puts sprintf("%-20s: \t%s\n", "IMAGE_AMI", "#{::IMAGE_AMI}")
        puts sprintf("%-20s: \t%s\n", "INSTANCE_TYPE", "#{::INSTANCE_TYPE}")
        puts sprintf("%-20s: \t%s\n", "SECURITY_GROUPS", "#{::SECURITY_GROUPS.join ', '}")
        puts sprintf("%-20s: \t%s\n", "KEY_NAME", "#{::KEY_NAME}")
        puts sprintf("%-20s: \t%s\n", "VOLUMES", "#{::VOLUMES.inspect}")
        puts sprintf("%-20s: \t%s\n", "ADDRESSES", "#{::ADDRESSES.join ', '}")
        puts sprintf("%-20s: \t%s\n", "HOSTSFILE_URL", "#{::HOSTSFILE_URL}")
        puts
        exit! 0
      end
      
      parser.on_tail('-h', '--help', 'Show this message') do
        self.help!
      end
      
      parser.on_tail('--version', 'Show version') do
        puts "This script built on: #{BUILD_DATE.to_s}"
        exit!
      end
      
      result = parser.parse!
      
      unless not options.exit
        puts parser.help if options.help
        exit
      end

      result 
    end
    
    begin
      validate_options
    rescue OptionParser::MissingArgument => e
      puts e.message
      puts 
      puts parser.help
      exit
    end
    
    options
  end

  def build; end
  def setup; end
  def validate_options; end
  protected :build, :setup

end

###############################################################################################################
################################################# Commands ####################################################
###############################################################################################################

class ServerCommand
  
  attr_reader :options, :aws_config, :aws_context, :ec2, :s3
  
  def self.instance
    @@executor ||= begin
      options = CommandParser.instance.parse
      unless COMMANDS.include? options.command
        ServerCommand.new(options)
      else
        ServerCommand.const_get(options.command.to_s.capitalize).new(options)
      end
    end
  end

  def initialize options
    require 'AWS/EC2'
    require 'basic_configuration'
    require 'aws_context'

    @options = options
    @aws_config  = BasicConfiguration.new
    @aws_context = AwsContext.instance

    @ec2 = @aws_context.ec2(*@aws_config.keys)
    @ec2.debug = options.debug
    if options.command == :hosts and options.subcommand == :put
      @s3 = @aws_context.s3(*@aws_config.keys)
      @s3.debug = options.debug
    end

    setup unless not respond_to? :setup
  rescue Exception => e
    subcmd = options.subcommand && options.subcommand != :missing ? "[#{options.subcommand.to_s}]" : "\b"
    puts "Command '#{options.command.to_s}' #{subcmd} failed due to the following error:"
    puts
    unless options.trace
      puts "#{e.message}"
    else
      puts "#{e.message}\n\t#{e.backtrace.join("\n\t")}"
    end
    exit 2
  end
  
  def get_s3_object uri
    require 'net/http'

    url = URI.parse(uri)
    http = Net::HTTP.new(url.host, url.port)
    http.set_debug_output $stderr if @options.debug
    result = http.start do |http|
      response, body = http.get(url.path)
      body || response.body
    end
  end

  def host_lookup instance_id
    begin
      @@json ||= JSON.parse(get_s3_object(::HOSTSFILE_URL.gsub(/hosts$/, 'json'))).symbolize_keys
      @@json[:all].collect do |hostname,instances|
        instances.select { |host| host[:cloud_id] == instance_id }
      end.flatten.first
    rescue Exception
      return { :server_id => nil }
    end
  end
  
  def get_instance_list only_active = true, force_list = false
    my_sg = ::SECURITY_GROUPS.sort.join ' '

    @@instance_list = nil unless not force_list

    @@instance_list ||= @ec2.describe_instances.inject({}) do |instances,group|  
      sg = group[:groups].sort.join(' ')
      group[:instances].each do |i|
        hostinfo = host_lookup i[:id]
        if sg == my_sg or hostinfo.try(:[], :server_id) == ::SERVER_ID
          instances[i[:id]] = {
            :id       => i[:id],
            :state    => i[:state],
            :ami      => i[:image_id],
            :dns      => i[:public_dns],
            :groups   => sg.split(/\s+/),
            :roles    => hostinfo.try(:[], :roles).try(:split, /\s*,\s*/),
            :server   => hostinfo.try(:[], :server_name),
            :cluster  => hostinfo.try(:[], :cluster_name),
            :account  => hostinfo.try(:[], :account_name),
            :provider => hostinfo.try(:[], :provider_name),
            :up_since => Time.parse(i[:launch_time]).getlocal
          } unless (!!only_active && i[:state] != 'running')
        end
      end
      instances
    end
  end

  def setup_readline
    # Default
    @libedit = false
    
    # If NotImplemented then this might be libedit
    begin
      Readline.emacs_editing_mode
    rescue NotImplementedError
      @libedit = true
    end
      
    stty_save = `stty -g`.chomp
    trap('INT') { system('stty', stty_save); exit }
  end

  def instance_display_list instances, display_keys = [ :state, :ami, :cluster, :server, :dns ]
    instances.values.sort{|a,b| a[:up_since] <=> b[:up_since]}.collect do |data|
      "#{data[:id]}: #{display_keys.collect { |k| data[k] }.compact.join " - "} (up since: #{data[:up_since]})" 
    end
  end
  
  def choose_instance only_active = true
    setup_readline
    
    instances = get_instance_list(only_active)
    
    list = instances.keys + [ 'quit', 'all' ]
    list.collect { |i| i += ' ' } if !!@libedit
    
    comp = proc { |s| list.grep( /^#{Regexp.escape(s)}/ ) }
    Readline.completion_append_character = " "
    Readline.completion_proc = comp
    
    while true
      puts "Choose an Instance:\n\n\t#{instance_display_list(instances).join("\n\t")}\n\n"
      selection = Readline.readline("(use quit to exit, use 'all' for all instances)\n> ", true).strip
      break if list.include?(selection) 
    end
    
    exit! if selection == 'quit'

    unless selection == 'all'
      [ instances[selection] ]
    else
      instances.collect { |k,v| v }
    end
  end
  
  def run() puts "Nothing to do."; end
  def setup; end
  protected :run, :setup
  
  def execute
    run
  rescue Exception => e
    subcmd = options.subcommand && options.subcommand != :missing ? "[#{options.subcommand.to_s}]" : "\b"
    puts "Command '#{options.command.to_s}' #{subcmd} failed due to the following error:"
    puts
    unless options.trace
      puts "#{e.message}"
    else
      puts "#{e.message}\n\t#{e.backtrace.join("\n\t")}"
    end
  end
end

###############################################################################################################
######################################### Instance Specific ###################################################
###############################################################################################################

class InstanceSpecific < ::CommandParser
  def setup
    options.cloud_id = nil
  end

  def build
    parser.banner += "[-i <Cloud ID>]"
    parser.on('-i [ID]', '--cloud-id [ID]', String,
              '[optional] The Cloud ID of the instance this action should be',
              'performed on. Note: You will be presented a list of IDs to choose ',
              'from if you do not provide one.' 
    ) { |v| options.cloud_id = v }
  end
end

class ServerCommand::InstanceSpecific < ServerCommand
  attr_reader :instances
  
  def setup
    super 
    unless options.cloud_id
      puts "Getting list of instances for user selection..."
      @instances = choose_instance
      options.cloud_id = (@instances.size > 1 ? 'all' : @instances.first[:id]) rescue 'missing'
    else
      puts "Getting instance '#{options.cloud_id}' details.."
      @instances = [ get_instance_list(true)[options.cloud_id] ] rescue []
    end
    @instances
  end
end

###############################################################################################################
#################################################### RUN ####################################################
###############################################################################################################

class Run < InstanceSpecific
  def setup
    options.ssh_key_file = nil 
  end
  
  def lead_in
    parser.separator "Run Description:"
    parser.separator "    RUN provides a mechanism for sending a shell command (via ssh)"
    parser.separator "    to all instances of the given server. Pass --keyfile <keyfile> to use"
    parser.separator "    to use a key other than the one defined in your aws_config.ini"
    parser.on('--keyfile [KEYFILE]',
              '[optional] Path to key file to use when making ssh connection to server hosts'
    ) { |v| options.ssh_key_file = v }
  end
end

class ServerCommand::Run < ServerCommand::InstanceSpecific
  def setup
    super
    options.ssh_key_file ||= @aws_config.aws[:aws_key] 
    @command = ARGV[0].nil? ? ($stdin.has_data? ? $stdin.read : nil) : ARGV[0]
    raise ArgumentError, 'no command specified...' if @command.nil?
  end
      
  def send(command, host)
    # switch to using instance id and run-cmd-instance ?
    ssh_opts = %w{ StrictHostKeyChecking=no ConnectTimeout=5 }
    opt = "StrictHostKeyChecking=no"
    cmd = "ssh -i #{options.ssh_key_file} -o #{ssh_opts.join ' -o '} root@#{host} '#{command}'"
    system(cmd)
  end
  
  def run
    unless @instances.empty?
      @instances.each do |instance|
        puts "  -> Sending command to instance '#{instance[:id]}' using hostname '#{instance[:dns]}'"
        send @command, instance[:dns]
      end
    end
  end
end

###############################################################################################################
#################################################### HOSTS ####################################################
###############################################################################################################

class Hosts < ::CommandParser
  def setup
    options.filename = nil
    options.json = false
    options.subcommand = (ARGV[0]||'missing').downcase.to_sym
  end

  def validate_options
    raise OptionParser::MissingArgument, "Missing required argument 'file'" if options.filename.nil? and options.subcommand == :put
  end

  def lead_in
    case options.subcommand
      when :get
        parser.separator "Hosts Get Description:"
        parser.separator "    Retrieves the hosts file which this server uses. Providing"
        parser.separator "    a filename through -f will cause it to be stored in the file"
        parser.separator "    and not displayed on STDOUT."
      when :put
        parser.separator "Hosts Put Description:"
        parser.separator "    Updates the hosts file which this server uses. You must"
        parser.separator "    provide a filename through -f to use as the new hosts file."
      else
        parser.separator "Hosts Description:"
        parser.separator "    Display or Update the hosts file which this server uses."
    end
  end
  
  def build
    unless [:put, :get].include? options.subcommand
      parser.banner += '<sub-command> [options]'
      options.subcommand = :missing
      parser.separator ""
      parser.separator "Valid sub-commands:"
      parser.separator "  get   - Get server hosts file from s3 storage"
      parser.separator "  put   - Update server hosts file on s3 storage"
      parser.separator ""
      self.help!
    else
      ARGV.shift
    end

    parser.separator "Common Sub-Command Options:"
    parser.on('--json',
              '[optional] Get/Store JSON version of hosts file instead of normal /etc/hosts format'
    ) { |v| options.json = true }
    
    case options.subcommand
      when :get
        parser.banner += 'get [-f FILE]'
        parser.on('-f [FILE]', '--file [FILE]', '[optional] File to store downloaded hosts to') {|f| options.filename = f }
      when :put
        parser.banner += 'put -f FILE'
        parser.on('-f FILE', '--file FILE', 'File to push containing new list of hosts') {|f| options.filename = f }
    end
  end
end

class ServerCommand::Hosts < ServerCommand
  def setup
    unless options.subcommand == :get
      if options.filename.nil?
        puts "Missing required argument 'file' !!"
        exit! 2
      elsif not File.exists? options.filename
        puts "required file '#{options.filename}' is missing!"
        exit! 2
      end
    end
  end

  def run
    case options.subcommand
      when :put
        s3_bucket_name, s3_object_path = ::HOSTSFILE_URL.gsub('http://','').split(/.s3.amazonaws.com\//)
        s3_object_path.gsub!(/\.hosts$/, '.json') unless not options.json
        
        opts = { :data => IO.read(options.filename), :policy => 'public-read' }
        obj = s3.create_object(s3_bucket_name, s3_object_path, opts)
      when :get
        hosts_uri = !!options.json ? ::HOSTSFILE_URL.gsub(/\.hosts$/, '.json') : ::HOSTSFILE_URL
        hosts_data = get_s3_object(hosts_uri)

        if options.filename.nil?
          puts hosts_data
        else 
          puts "Retrieved hosts data for server '<%= user_script.server.name -%>' from '#{::HOSTSFILE_URL}'"
          File.open(options.filename, 'w') { |f| f << hosts_data }
        end
    end
  end
end

###############################################################################################################
#################################################### LISTS ####################################################
###############################################################################################################

class List < ::CommandParser
  def lead_in
    parser.separator "List Description:"
    parser.separator "    Attempts to list instances of this particular server. "
    parser.separator "    Of course it should be noted that, due to a lack tags, it is"
    parser.separator "    very difficult to guarantee that this will be accurate."
    parser.separator "    YOU HAVE BEEN WARNED."
  end
end

class ServerCommand::List < ServerCommand
  def run
    puts "Possible Instance Matches:"
    puts "\t#{instance_display_list(get_instance_list()).join("\n\t")}"
  end
end

###############################################################################################################
################################################### REBOOT ####################################################
###############################################################################################################

class Reboot < InstanceSpecific
  def lead_in
    parser.separator "Reboot Description:"
    parser.separator "    REBOOT sends the reboot command to the selected instance"
  end
end

class ServerCommand::Reboot < ServerCommand::InstanceSpecific
  def run
    unless @instances.empty?
      ec2.reboot_instances(@instances.collect { |instance| instance[:id] })
    end
  end
end

###############################################################################################################
####################################################  STOP ####################################################
###############################################################################################################

class Stop < InstanceSpecific
  def lead_in
    parser.separator "Stop Description:"
    parser.separator "    STOP sends the shutdown command to the selected instance"
  end
end

class ServerCommand::Stop < ServerCommand::InstanceSpecific
  def run
    unless @instances.empty?
      response = ec2.terminate_instances(@instances.collect { |instance| instance[:id] })
      response.each do |instance|
        puts "Stopping instance '#{instance[:id]}' - state now: #{instance[:state]}"
      end
    end
  end
end

###############################################################################################################
#################################################### START ####################################################
###############################################################################################################

class Start < ::CommandParser
  def setup
    options.dumpdata = false
    options.force_reallocation = false
  end
  
  def lead_in
    parser.banner += "[-DF]"

    parser.separator "Start Description:"
    parser.separator "    Attempts to start one instance of this particular server. If you "
    parser.separator "    specify force-reallocation, any resources (EIP, Volumes, etc) will "
    parser.separator "    be detached from any server they are currently attached to and"
    parser.separator "    reattached to the new instance. Not specifying the option will cause"
    parser.separator "    the script to ask you if you would like to reallocate any resources"
    parser.separator "    before actually doing so."
  end

  def build
    parser.on('-D', '--dumpdata',
             'Dumps the user_data for this server to STDOUT'
    ) { |v| options.dumpdata = !!v }
    
    parser.on('-F', '--force-reallocation',
             'Forces all resources to be reallocated to first',
             'instance started by this command'
    ) {|v| options.force_reallocation  = !!v }
  end
end

class ServerCommand::Start < ServerCommand
  def have_volumes?
    !!(true unless ::VOLUMES.empty?)
  end
  
  def have_addresses?
    !!(true unless ::ADDRESSES.empty?)
  end
  
  def ask message
    begin
      printf "\n#{message + ' [y/n] '}"
    end while ((selection = $stdin.gets) !~ /^(y|n)/i)
    !!(selection =~ /^y/)
  end
  
  def run
    unless not options.dumpdata
      puts ::USER_DATA
      exit! 2
    end

    params = {
      :instance_type => ::INSTANCE_TYPE,
      :security_groups => ::SECURITY_GROUPS,
      :key_name => ::KEY_NAME,
      :user_data => ::USER_DATA,
      :zone => ::ZONE.empty? ? nil : ::ZONE
    }
    
    response = @ec2.run_instances(::IMAGE_AMI, 1, 1, params)
    
    unless response.nil?
      require 'timeout'
      requested_id = response[:instances].first[:id]

      if have_volumes? or have_addresses?
        begin
          Timeout::timeout(300) do |sec|
            timeout_at = Time.now.to_i + sec
            while (get_instance_list(true,true)[requested_id].nil?)
              puts "Waiting #{timeout_at - Time.now.to_i} more seconds for new instance '#{requested_id}' to start..."
              sleep 2
            end
          end
        rescue Timeout::Error
          raise "Timed out waiting for new instance '#{requested_id}' to start." unless not timed_out
        end
        
        ec2 = Ec2.new(@ec2, requested_id)
        
        unless not have_volumes?
          ::VOLUMES.each do |volume_id, mount_point|
            unless not ec2.attached? volume_id
              force = options.force_reallocation ||
                      ask("Volume with id '#{volume_id}' is already attached to another instance.\n" +
                          "Should I force reattachment to this new instance? [N/y]")               

              next unless force

              ec2.detach(volume_id, nil, nil, true)
              puts "Waiting for detachment before continuing (timeout in 30 seconds) ..."
              
              begin
                Timeout::timeout(30) { sleep 1 while (ec2.attached?(volume_id)); true }
              rescue Timeout::Error
                puts "Timed out waiting for detachment of volume '#{volume_id}' - please attach manually!"
                next
              end # unless not force
            end # unless not attached
            
            puts "Attaching volume '#{volume_id}' to instance '#{requested_id}' at mount point '#{mount_point}'"
            ec2.attach volume_id, mount_point
          end
        end
        
        unless not have_addresses? 
          ::ADDRESSES.each do |address|
            unless not ec2.associated? address
              force = options.force_reallocation ||
                      ask("Address with id '#{address}' is already associated with another instance.\n" +
                          "Should I force reassociation to this new instance? [N/y]")

              next unless force

              ec2.disassociate(address)
              puts "Waiting for disassocation before continuing (timeout in 30 seconds) ..."
              
              begin
                Timeout::timeout(30) { sleep 1 while (ec2.associated?(address)); true }
              rescue Timeout::Error
                puts "Timed out waiting for disassociation of address '#{address}' - please associate manually!"
                next
              end # unless not force
            end # unless not associated
            
            puts "Associating address '#{address}' with instance '#{requested_id}'"
            ec2.associate address
          end
        end
      end
    else
      raise 'Unable to start new instance'
    end
    
  end
end

ServerCommand.instance.execute

__END__
<%= user_script.data %>